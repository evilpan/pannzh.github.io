---
layout: post
title:  "GDB调试笔记"
date:   2015-10-28 21:30:00
comments: true
categories: Tech
---
GDB是在Linux命令行下对C/C++的程序进行调试常用的一个命令，现将平时记录在本子上的笔记整理如下：

---------

一、断点
----------

断点类型有breakpoints, watchpoints, catchpoints.

#### 1).breakpoints:　
普通断点，程序运行到该点时暂停（此时此行尚未运行），是gdb中最常用的断点，相关命令为：  

> *break [函数名，行数或者指令地址]  [condi]*  

在指定地方加上断点
例：  

> *(gdb) set $counter = 0*  
> *(gdb) break 26 if ++$counter == 99*

在第26行设置断点，每次触发断点的时候执行判断条件，仅在判断条件为真的时候使程序在断点处停止。在循环的debug中很好用。
类似的命令还有condition等。
*rbreak RE:*  
在所有符合正则表达式RE的函数上加上断点

#### 2).watchpoints：
也称为data breakpoints，在表达式值变化时停止执行的断点。
> *watch expr[thread threadnum]*  
表达式可以是变量值，地址（如*(int *)0x12345678)或数学表达式。

#### 3).catchpoints:
程序事件断点，如c++异常

> *catch event* 　　:event可以是 throw或catch事件

**查看断点：**

> *info breakpoint[n]*　
打印所有（或者第n个）断点信息，同 info break
> *info watchpoints[n]*　　: 同上

**删除断点：**

> *delete [断点号] [range...]*　　：range是断点号，空格分割
> 
> *clear location* 　　:location是函数名，行数等
> 
> *enable/disable*　　:使能/使失效断点，不删除

**其他**

为断点号bnum写一个命令列表，程序运行到断点时gdb会依次运行列表中的命令:  
> commands [bnums]
> 　　...command list...
>   end

二、单步调试
------------

#### 1）基本命令：

> *step:*运行下一步（即step into，进入调用的函数体内）
> *next：*同上，但是不进入函数体
> *finish：*往下运行直至当前栈帧（下面解释）中的函数返回
> *continue：*往下运行直至遇到断点

**打印信息：**

> *print/x data：*
以x（十六进制）格式打印数据data的值（或者缩写为p/x data）;
输出格式有x、d、u、o、t（二进制，two，因为b已经用来表示byte）、a（address）、c（char）、f（float）、s（string）、r（raw）　　　　　

查看数据类型： ptype data;

打印数组： p *array@len

　　　　

#### 2）栈帧（stack frame）
stack frame 是在栈中为参数、返回地址和局部变量保留的一块内存区，必要时在过程调用中使用，相关命令：

> *frame[args]：*
从一个栈帧移动到另一个，并打印选择的栈帧。args可以是栈帧号或其地址。
> *info frame []：*
查看栈帧的详细信息
> *backtrace：*
向后追踪栈帧（调用）

 

####3）底层信息：

**查看汇编：**disassemble [option] [range]

接收一个参数时，打印该地址周围的函数的汇编，接收两个参数时，表示需要dump的范围

**查看内存：**x  /nfu addr

n：重复数。默认为1,表示要显示多少内存（以单元u为基数）

f：显示格式。同print，默认为x， i表示机器指令

u：单元大小。分别可以是b（byte）、h（halfwords，=2byte）、w（words，=4byte）和g（gaint words，=8byte）;默认为w

　　寄存器：

$pc：程序计数器，值为下一条指令的地址

$ps：程序状态寄存器

$sp：stack pointer栈指针

$fp：frame pointer 指向当前栈帧的指针

 

三、变更执行
--------------

#### 1）修改变量

> print i=num，赋值并打印变量i
> set i=num，仅赋值

#### 2）修改内存

　　用'{...}'结构来生成地址。如：

> *set {int}0x83040 = 4;　　//将4存储到地址0x83040中*

#### 3）跳转

> jump [location]

location可以是行号或者地址。注意jump命令仅仅改变$pc的值，而不改变当前栈帧、堆栈指针或上下文，效果相当于set $pc = {int}location

#### 4）中断

> *signal sig*
立即将信号sig发给程序

#### 5）其他

> return：使（函数）返回
